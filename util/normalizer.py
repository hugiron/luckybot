import re
from pymystem3 import Mystem


stopwords = {'меня', 'ему', 'теперь', 'вдруг', 'нибудь', 'опять', 'уж', 'ведь', 'потом', 'себя', 'ничего', 'ей', 'тут',
             'ней', 'тебя', 'сам', 'чтоб', 'будто', 'раз', 'себе', 'будет', 'ж', 'тогда', 'этот', 'потому', 'этого',
             'какой', 'совсем', 'ним', 'этом', 'один', 'почти', 'мой', 'сейчас', 'куда', 'зачем', 'никогда', 'можно',
             'наконец', 'два', 'другой', 'хоть', 'после', 'над', 'больше', 'тот', 'через', 'нас', 'про', 'какая',
             'много', 'разве', 'три', 'эту', 'моя', 'впрочем', 'хорошо', 'свою', 'этой', 'перед', 'иногда', 'лучше',
             'чуть', 'нельзя', 'всегда', 'конечно', 'всю', 'между', 'а', 'без', 'более', 'бы', 'был', 'была', 'были',
             'было', 'быть', 'в', 'вам', 'вас', 'весь', 'во', 'вот', 'все', 'всего', 'всех', 'вы', 'где', 'да', 'даже',
             'для', 'до', 'его', 'ее', 'если', 'есть', 'еще', 'же', 'за', 'здесь', 'и', 'из', 'или', 'им', 'их', 'к',
             'как', 'ко', 'когда', 'кто', 'ли', 'либо', 'мне', 'может', 'мы', 'на', 'надо', 'наш', 'не', 'него', 'нее',
             'нет', 'ни', 'них', 'но', 'ну', 'о', 'об', 'однако', 'он', 'она', 'они', 'оно', 'от', 'очень', 'по', 'под',
             'при', 'с', 'со', 'так', 'также', 'такой', 'там', 'те', 'тд', 'тп', 'тн', 'тем', 'то', 'того', 'тоже',
             'той', 'только', 'том', 'ты', 'у', 'уже', 'хотя', 'чего', 'чей', 'чем', 'что', 'чтобы', 'чье', 'чья',
             'эта', 'эти', 'это', 'я'}


class Normalizer:
    def __init__(self):
        url_regex = r"https?:\/\/)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*"
        notify_regex = r"\[.*\|.*\]"
        tag_regex = r"#[^\s]+"

        self.regex = re.compile(r'(%s)|(%s)|(%s)' % (url_regex, notify_regex, tag_regex))
        self.mystem = Mystem()

    def normalize(self, text):
        return self.filter(self.mystem.lemmatize(self.regex.sub(" ", self.preprocess(text))))

    def preprocess(self, text):
        return text.lower().replace("<br>", " ").replace("\n", " ")

    def filter(self, lemms):
        return [lemm for lemm in lemms if lemm not in stopwords and lemm.isalpha() and len(lemm) > 1]
